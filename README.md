# Задание 3

Мобилизация.Гифки – сервис для поиска гифок в перерывах между занятиями.

1. Проблема "Разложить файлы красиво" - необходимо перенести `service-worker.js` в директорию `entrance-task-3`. Т.к. `service worker` обрабатывает те запросы, которые находятся в зоне его видимости (`scope`). Максимальная зона видимости - местоположение `service-worker.js`.
!https://mdn.mozillademos.org/files/12630/important-notes.png
Соответственно необходимо изменить "адрес" `service worker`a при его регистрации в файле `blocks.js`.

2. Проблема "Более надёжное кеширование на этапе `fetch` и его последствия - для того чтобы `gifs.html` попал в кеш, определили его как файл для загрузки на этапе инициаллизации и заносим его в кеш там же.

Можно так же занести файл в
`function needStoreForOffline(cacheKey) {
    return cacheKey.includes('vendor/') ||
        cacheKey.includes('assets/') ||
        cacheKey.endsWith('jquery.min.js');
}`
но тогда, он будет постоянно браться из кеша и придется изменять логику обработчика `fetch`.
Или же статические ресурсы загружать на этапе инициаллизации. Но тогда, если один из них не загрузится, `service worker` не установится, что тоже плохо.
Поэтому принято решение файл с разметкой загружать на этапе инициаллизации. Что позволит с одной стороны, загрузить его в кеш, что обеспечит работу в офлайн режиме. А с другой стороны не потребует именеий обработчика `fetch`-запросов. Файл будет браться из кеша, только в офлайн режиме что и требуется.

3. Проблема "невозможно обновить статику из директорий `vendor` и `assets`" - для обновления ресурсов необходимо изменить `CACHE_VERSION`. Тогда будет вызван метод `deleteObsoleteCaches()`.


## Ответы на вопросы, помеченный в файле `service-worker.js`:

1. Вызов метода `skipWaiting()`
Данный вызов необходим при обновленнии `service worker`а. После того, как обновленный `service worker` успешно регистрируется на странице, он не начинает немедленно обрабатывать запросы. Вместо этого он будет находится в режиме ожидания, в то время как предыдущий `service worker` будет продолжать свою работу.
Новый `service worker` начнет функционировать только после того как все подконтрольные старому `service worker`у страницы будут закрыты.
Вызов метода `skipWaiting` изменяет поведение так, что обновленный `service worker` немедленно начинает работу.
!https://developers.google.com/web/fundamentals/instant-and-offline/service-worker/lifecycle

2. Вызов метода `clients.claim()`
Даже после успешной регистрации `service worker` начинает контролировать страницу только после того как станет активным, то есть только после перезагрузки страницы. Вызов `clients.claim()` позволяет переопределить такое поведение.
В данном случае, этот вызов необходим, для того, чтобы закешировать ресурсы `/assets` и `/vendor`. Так как они не кешируются на этапе регистрации `service worker`а.

3. Для всех ли случаев подойдет такой ключ `url.origin + url.pathname`
Если у запроса будет значимый параметр `url.search` при таком построении ключа он не будет учтен.
Например для запроса https://yandex.ru/images/search?text=cat будет составлен ключ https://yandex.ru/images/search
!https://pix.my/tjH7VL

4. Зачем нужна цепочка вызовов `name !== CACHE_VERSION`
При обновлении `service worker`а необходимо изменить версию кеша с которой он будет взаимодействовать.
Это нужно для того, чтобы безболезненно записывать новые данные, не повреждая при этом данные того кеша, которым пользуется предыдущая версия `service worker`а, находящаяся в работе.
Однако, когда новая версия `service worker`а становится активной (у старой версии `service worker`а не осталось подконтрольных страниц), предыдущая версия кеша может быть удалена. Что и производится в цепочке вызовов.

5. "Для чего нужно клонирование?"
Потоки запроса и ответа могут быть прочитаны только единожды. Чтобы ответ был получен браузером и сохранен в кеше — нужно клонировать его.
Так, оригинальный объект отправится браузеру, а клон будет закеширован.
